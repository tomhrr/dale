#|
@module macros

Provides the core macro development functions: making, copying and
printing nodes, linking nodes together, gensym functions for
variables and labels, and the quasiquotation form.

|#
(module macros (attr cto))

(import cstdio-core)
(import introspection)

(namespace std (namespace macros

#|
@fn std.macros.make-node

Returns a newly-allocated node.

@param mc An MContext.
|#
(def make-node
  (fn extern (p DNode) ((mc (p MContext)))
    (def dnsize (var auto size (sizeof DNode)))
    (def n (var auto (p DNode)
                     (cast (pool-malloc mc dnsize) (p DNode))))
    (memset (cast n (p void)) 0 (sizeof DNode))
    (setf (: (@ n) filename) (nullptr char))
    n))

#|
@fn std.macros.is-empty-node

Returns a boolean indicating whether the node is an empty node (no
list and no token).

@param form     The node.
|#
(def is-empty-node
  (fn extern bool ((form (p DNode)))
    (if (= 0 (@:@ form is-list))
        (if (null (@:@ form token-str))
            true
            false)
        false)))

#|
@fn std.macros.make-empty-list-node

Returns a newly-allocated empty list node.

@param mc An MContext.
|#
(def make-empty-list-node
  (fn extern (p DNode) ((mc (p MContext)))
    (def node (var auto \ (make-node mc)))
    (setf (:@ node is-list) 1)
    (return node)))

#|
@fn std.macros.is-non-empty-list

@param form     The node.
|#
(def is-non-empty-list
  (fn extern bool ((form (p DNode)))
    (if (= 1 (@:@ form is-list))
        (if (not (null (@:@ form list-node)))
            true
            false)
        false)))

#|
@fn std.macros.copy

@param mc An MContext.
@param follow   Whether to include the nodes that follow `form`.
@param form     The node to copy.
@return         A copy of `form`.
|#
(def copy
  (fn extern (p DNode) ((mc   (p MContext))
                        (follow     bool)
                        (form       (p DNode)))
    (def nullp    (var auto (p DNode) (cast 0 (p DNode))))
    (def new-node (var auto (p DNode) (make-node mc)))

    (memcpy (cast new-node (p void))
            (cast form     (p void))
            (cast (sizeof DNode) int))

    (if (not (null (@:@ form list-node)))
        (setf (:@ new-node list-node)
              (copy mc true (@:@ form list-node)))
        true)

    (setf (:@ new-node next-node)
          (if follow
              (if (not (null (@:@ form next-node)))
                  (copy mc true (@:@ form next-node))
                  nullp)
              nullp))

    (return new-node)))

#|
@fn std.macros.copy-qstr

As per `copy`, except that if the first node is a token, it will have
double-quotations marks added at the start and end of it in the copied
node.

@param mc An MContext.
@param form     The node to copy.
@param follow   Whether to include the nodes that follow `form`.
@return         A copy of `form`.
|#
(def copy-qstr
  (fn extern (p DNode) ((mc   (p MContext))
                        (form       (p DNode))
                        (follow bool))
    (def nullp    (var auto (p DNode) (cast 0 (p DNode))))
    (def new-node (var auto (p DNode) (make-node mc)))
    (def dquote   (var auto char #\"))
    (def len      (var auto size 0))
    (def charbuf  (var auto (p char)
        (cast (pool-malloc mc (cast 256 size)) (p char))))

    (if (= 0 (@:@ form is-list))
        (do
            (setf ($ charbuf 0) dquote)
            (setv len (strlen (@ (: (@ form) token-str))))
            (strncpy ($ charbuf 1) (@ (: (@ form) token-str)) len)
            (setf ($ charbuf (+ (cast 1 size) len)) dquote)
            (setf ($ charbuf (+ (cast 2 size) len)) #\NULL)
            (setf (:@ new-node is-list)   0)
            (setf (:@ new-node token-str) charbuf)
            (setf (:@ new-node list-node) nullp)

            (setf (:@ new-node next-node)
                (if follow
                    (if (not (null (@:@ form next-node)))
                        (do (copy mc true (@:@ form next-node)))
                        nullp)
                    nullp)))
        (do
            (setf (:@ new-node is-list) 1)
            (if (not (null (@:@ form list-node)))
                (do (setf (:@ new-node list-node)
                          (copy mc true (@:@ form list-node)))
                    0)
                0)))

    (setf (:@ new-node begin-line) (@:@ form begin-line))
    (setf (:@ new-node begin-column) (@:@ form begin-column))
    (setf (:@ new-node end-line) (@:@ form end-line))
    (setf (:@ new-node end-column) (@:@ form end-column))
    (setf (:@ new-node macro-begin-line) (@:@ form macro-begin-line))
    (setf (:@ new-node macro-begin-column) (@:@ form macro-begin-column))
    (setf (:@ new-node macro-end-line) (@:@ form macro-end-line))
    (setf (:@ new-node macro-end-column) (@:@ form macro-end-column))

    (setf (:@ new-node next-node)
          (if follow
              (if (not (null (@:@ form next-node)))
                  (do (copy mc true (@:@ form next-node)))
                  nullp)
              nullp))

    (return new-node)))

#|
@fn std.macros.copy-to

Copy (shallow) the details of the source node to the destination node.

@param dst      The destination node.
@param src      The source node.
|#
(def copy-to
  (fn extern void ((dst (p DNode)) (src (p DNode)))
    (setf (:@ dst is-list)   (@:@ src is-list))
    (setf (:@ dst token-str) (@:@ src token-str))
    (setf (:@ dst list-node) (@:@ src list-node))
    (setf (:@ dst begin-line) (@:@ src begin-line))
    (setf (:@ dst begin-column) (@:@ src begin-column))
    (setf (:@ dst end-line) (@:@ src end-line))
    (setf (:@ dst end-column) (@:@ src end-column))
    (setf (:@ dst macro-begin-line) (@:@ src macro-begin-line))
    (setf (:@ dst macro-begin-column) (@:@ src macro-begin-column))
    (setf (:@ dst macro-end-line) (@:@ src macro-end-line))
    (setf (:@ dst macro-end-column) (@:@ src macro-end-column))
    (setf (:@ dst filename) (@:@ src filename))
    (return)))

#|
@fn std.macros.print

Prints the node to `stdout`.

@param form     The node to print.
|#
(def print
  (fn extern bool ((form (p DNode)))
    (if (= 0 (@:@ form is-list))
        (do (printf "%s" (@:@ form token-str))
            true)
        (do (printf "(")
            (if (not (null (@:@ form list-node)))
                (print (@:@ form list-node))
                true)
            (printf ")")
            true))
    (if (not (null (@:@ form next-node)))
        (do (printf " ")
            (return (print (@:@ form next-node))))
        true)))

#|
@fn std.macros.sprint

Prints the node to the provided buffer.

@param buf      The buffer to which the node will be printed.
@param form     The node to print.
|#
(def sprint
  (fn extern bool ((buf (p char)) (form (p DNode)))
    (def cc (var auto (p char) buf))
    (if (= 0 (@:@ form is-list))
        (do (sprintf buf "%s" (@:@ form token-str))
            (setv buf (strchr buf (cast #\NULL int)))
            true)
        (do (setf ($ buf 0) (cast 40 char))
            (setv buf (p+ buf 1))
            (setf buf #\NULL)
            (if (not (null (@:@ form list-node)))
                (sprint buf (@:@ form list-node))
                0)
            (setv buf (strchr buf (cast #\NULL int)))
            (setf ($ buf 0) (cast 41 char))
            (setv buf (p+ buf 1))
            (setf buf #\NULL)
            true))
    (if (not (null (@:@ form next-node)))
        (do (setf ($ buf 0) #\SPACE)
            (setv buf (p+ buf 1))
            (setf buf #\NULL)
            (return (sprint buf (@:@ form next-node))))
        true)))

#|
@fn std.macros.get-last-node

Returns the last node in the list, by iterating over `next-node`
(i.e. this does not descend into the `list-node` of the argument
node).

@param form     The node for which the last node should be found.
@return         The last node.
|#
(def get-last-node
  (fn extern (p DNode) ((form (p DNode)))
    (label begin-loop)
      (if (null (@:@ form next-node))
          (return form)
          (do (setv form (@:@ form next-node))
              (goto begin-loop)))))

#|
@fn std.macros.mnfv

Short for 'make-node-from-value'. There are several implementations of
this function: each is similar to `make-node`, except that each takes
an additional argument, which is used to populate the `token-str` of
the newly-allocated node. This implementation takes a `(p char)`,
copies it, and sets it in the new node.

@param mc               An MContext.
@param token-string     The token string for the new node.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (token-string (p (const char))))
    (def d-node (var auto (p DNode) (make-node mc)))
    (def nullp  (var auto (p DNode) (nullptr DNode)))
    (def charp  (var auto (p char)
                   (cast (pool-malloc mc (cast 256 size)) (p char))))
    (strncpy charp token-string (cast 256 size))
    (setf (:@ d-node is-list)   0)
    (setf (:@ d-node token-str) charp)
    (setf (:@ d-node list-node) nullp)
    (setf (:@ d-node next-node) nullp)
    (return d-node)))

#|
@fn std.macros.mnfv

@param mc An MContext.
@param n  An integer.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (n int))
    (def x (var auto (array-of 255 char)))
    (sprintf x "%d" n)
    (mnfv mc x)))

#|
@fn std.macros.mnfv

@param mc An MContext.
@param n  A uint64 integer.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (n uint64))
    (def x (var auto (array-of 255 char)))
    (sprintf x "%lu" n)
    (mnfv mc x)))

#|
@fn std.macros.mnfv

@param mc An MContext.
@param n  A int64 integer.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (n int64))
    (def x (var auto (array-of 255 char)))
    (sprintf x "%ld" n)
    (mnfv mc x)))

#|
@fn std.macros.mnfv

@param mc An MContext.
@param f  A float.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (f float))
    (def x (var auto (array-of 255 char)))
    (sprintf x "%f" f)
    (mnfv mc x)))

#|
@fn std.macros.mnfv

@param mc An MContext.
@param d  A double.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (d double))
    (def x (var auto (array-of 255 char)))
    (sprintf x "%f" d)
    (mnfv mc x)))

#|
@fn std.macros.mnfv

@param mc An MContext.
@param ld A long double.
|#
(def mnfv
  (fn extern (p DNode) ((mc (p MContext))
                        (ld long-double))
    (def x (var auto (array-of 255 char)))
    (sprintf x "%Lf" ld)
    (mnfv mc x)))

#|
@fn std.macros.mnfv-wp

Short for 'make-node-from-value-with-position'. Takes additional node
position arguments, and sets them accordingly on the new node. Only
implemented for `(p char)` values.

@param mc                   An MContext.
@param token-string         A string.
@param begin-line           The beginning line number for the node.
@param begin-column         The beginning column number for the node.
@param end-line             The ending line number for the node.
@param end-column           The ending column number for the node.
@param macro-begin-line     The beginning macro line number.
@param macro-begin-column   The beginning macro column number.
@param macro-end-line       The ending macro line number.
@param macro-end-column     The ending macro column number.
|#
(def mnfv-wp
  (fn extern (p DNode) ((mc (p MContext))
                        (token-string (p (const char)))
                        (begin-line int)
                        (begin-column int)
                        (end-line int)
                        (end-column int)
                        (macro-begin-line int)
                        (macro-begin-column int)
                        (macro-end-line int)
                        (macro-end-column int))
    (def n (var auto \ (mnfv mc token-string)))
    (setf (:@ n begin-line) begin-line)
    (setf (:@ n begin-column) begin-column)
    (setf (:@ n end-line) end-line)
    (setf (:@ n end-column) end-column)
    (setf (:@ n macro-begin-line) macro-begin-line)
    (setf (:@ n macro-begin-column) macro-begin-column)
    (setf (:@ n macro-end-line) macro-end-line)
    (setf (:@ n macro-end-column) macro-end-column)
    (return n)))

#|
@fn std.macros.link-nodes

Links the provided nodes together, without copying them, and returns
the first provided node. This is a varargs function. Note that the
`next-node` member of the last node is not nulled.

@param argcount     The number of nodes being provided.
@return             The first node that was provided.
|#
(def link-nodes
  (fn extern (p DNode) ((argcount int) ...)
    (def nullp  (var auto (p DNode) (cast 0 (p DNode))))
    (def very-fst-node (var auto (p DNode)))
    (def fst-node (var auto (p DNode)))
    (def snd-node (var auto (p DNode)))

    (def arglist (var auto va-list))
    (va-start (cast (# arglist) (p void)))

    (setv very-fst-node (va-arg (# arglist) (p DNode)))
    (setv fst-node very-fst-node)

    (label begin-loop)
        (if (= 1 argcount)
            (goto end-loop)
            (do
                (setv snd-node (va-arg (# arglist) (p DNode)))
                (setf (: (@ fst-node) next-node) snd-node)
                (setv fst-node (get-last-node snd-node))
                (setv argcount (- argcount 1))
                (goto begin-loop)))

    (label end-loop)
      (va-end (cast (# arglist) (p void)))
      (return very-fst-node)))

#|
@fn std.macros.link-nodes-list

As per `link-nodes`, except that an additional list node is allocated
and returned. This list node points to the first provided node as its
`list-node`.

@param mc       An MContext.
@param argcount The number of varargs being provided.
|#
(def link-nodes-list
  (fn extern (p DNode) ((mc (p MContext)) (argcount int) ...)
    (def link-node (var auto (p DNode) (make-node mc)))
    (def nullp  (var auto (p DNode) (cast 0 (p DNode))))

    (def very-fst-node (var auto (p DNode)))
    (def fst-node (var auto (p DNode)))
    (def snd-node (var auto (p DNode)))

    (def arglist (var auto va-list))
    (va-start (cast (# arglist) (p void)))

    (setv very-fst-node (va-arg (# arglist) (p DNode)))
    (setv fst-node very-fst-node)

    (label begin-loop)
        (if (= 1 argcount)
            (goto end-loop)
            (do
                (setv snd-node (va-arg (# arglist) (p DNode)))
                (setf (: (@ fst-node) next-node) snd-node)
                (setv fst-node (get-last-node snd-node))
                (setv argcount (- argcount 1))
                (goto begin-loop)))

    (label end-loop)
      (va-end (cast (# arglist) (p void)))
      (setf (:@ link-node is-list)   1)
      (setf (:@ link-node next-node) nullp)
      (setf (:@ link-node list-node) very-fst-node)
      (return link-node)))

#|
@fn std.macros.link-nodes-list-wp

As per `link-nodes-list`, except it also accepts additional node
position arguments, and sets them accordingly on the newly-allocated
list node.

@param mc                   An MContext.
@param argcount             The number of varargs being provided.
@param begin-line           The beginning line number for the node.
@param begin-column         The beginning column number for the node.
@param end-line             The ending line number for the node.
@param end-column           The ending column number for the node.
@param macro-begin-line     The beginning macro line number.
@param macro-begin-column   The beginning macro column number.
@param macro-end-line       The ending macro line number.
@param macro-end-column     The ending macro column number.
|#
(def link-nodes-list-wp
  (fn extern (p DNode) ((mc (p MContext))
                        (argcount int)
                        (begin-line int)
                        (begin-column int)
                        (end-line int)
                        (end-column int)
                        (macro-begin-line int)
                        (macro-begin-column int)
                        (macro-end-line int)
                        (macro-end-column int)
                        ...)
    (def link-node (var auto (p DNode) (make-node mc)))
    (def nullp  (var auto (p DNode) (cast 0 (p DNode))))

    (def very-fst-node (var auto (p DNode)))
    (def fst-node (var auto (p DNode)))
    (def snd-node (var auto (p DNode)))

    (def arglist (var auto va-list))
    (va-start (cast (# arglist) (p void)))

    (setv very-fst-node (va-arg (# arglist) (p DNode)))
    (setv fst-node very-fst-node)

    (label begin-loop)
        (if (= 1 argcount)
            (goto end-loop)
            (do
                (setv snd-node (va-arg (# arglist) (p DNode)))
                (setf (: (@ fst-node) next-node) snd-node)
                (setv fst-node (get-last-node snd-node))
                (setv argcount (- argcount 1))
                (goto begin-loop)))

    (label end-loop)
      (va-end (cast (# arglist) (p void)))
      (setf (: (@ link-node) is-list)   1)
      (setf (: (@ link-node) next-node) nullp)
      (setf (: (@ link-node) list-node) very-fst-node)

      (setf (: (@ link-node) begin-line) begin-line)
      (setf (: (@ link-node) begin-column) begin-column)
      (setf (: (@ link-node) end-line) end-line)
      (setf (: (@ link-node) end-column) end-column)
      (setf (: (@ link-node) macro-begin-line) macro-begin-line)
      (setf (: (@ link-node) macro-begin-column) macro-begin-column)
      (setf (: (@ link-node) macro-end-line) macro-end-line)
      (setf (: (@ link-node) macro-end-column) macro-end-column)

      (return link-node)))

#|
@fn std.macros.link-nodes-array

As per `link-nodes`, except that instead of being a varargs function,
it takes an array of nodes as its second argument.

@param argcount     The number of arguments in the array.
@param arg-array    The argument array.
|#
(def link-nodes-array
  (fn extern (p DNode) ((argcount int) (arg-array (p (p DNode))))
    (if (= argcount 0)
        (return (nullptr DNode))
        0)

    (def nullp  (var auto (p DNode) (cast 0 (p DNode))))
    (def very-fst-node (var auto (p DNode)))
    (def fst-node      (var auto (p DNode)))
    (def snd-node      (var auto (p DNode)))

    (setv very-fst-node (@ arg-array))
    (setv fst-node very-fst-node)
    (setv arg-array (p+ arg-array 1))
    (setv argcount (- argcount 1))

    (label begin-loop)
        (if (= 0 argcount)
            (goto end-loop)
            (do
                (setv snd-node (@ arg-array))
                (setf (: (@ fst-node) next-node) snd-node)
                (setv fst-node snd-node)
                (setv argcount (- argcount 1))
                (setv arg-array (p+ arg-array 1))
                (goto begin-loop)))

    (label end-loop)
      (return very-fst-node)))

(def var-marker (var intern int 0))
#|
@fn std.macros.gensym-var

Prints a new, unused variable name to the provided buffer.

@param buf      The buffer for the variable name.
|#
(def gensym-var
  (fn extern bool ((buf (p char)))
    (sprintf buf "_dale_internal_var_%d" var-marker)
    (setv var-marker (+ var-marker 1))
    true))

(def label-marker (var intern int 0))
#|
@fn std.macros.gensym-label

Prints a new, unused label name to the provided buffer. The prefix is
included in the new label name, so that it is a little easier to
determine what's happening when errors occur in the generated code.

@param buf      The buffer for the label name.
@param prefix   The prefix for the label name.
|#
(def gensym-label
  (fn extern bool ((buf (p char)) (prefix (p (const char))))
    (if (null prefix)
        (setv prefix "na")
        true)
    (sprintf buf "_dale_internal_label_%s_%d" prefix label-marker)
    (setv label-marker (+ label-marker 1))
    true))

#|
@fn std.macros.make-gensym-label-node

Generates a new label name, constructs a token node to suit and
returns that node.

@param mc An MContext.
@param prefix   The prefix for the label name.
|#
(def make-gensym-label-node
  (fn extern (p DNode) ((mc (p MContext)) (prefix (p (const char))))
    (def label-name
        (var auto (p char)
                  (cast (pool-malloc mc (cast 150 size)) (p char))))
    (gensym-label label-name prefix)
    (mnfv mc label-name)))

#|
@fn std.macros.make-gensym-label-node

As per the previous implementation, except that no prefix is required
(it is set to the empty string).

@param mc An MContext.
|#
(def make-gensym-label-node
  (fn extern (p DNode) ((mc (p MContext)))
    (make-gensym-label-node mc "")))

#|
@fn std.macros.is-gensym-label

Determines whether the provided label node is a gensym label with the
specified prefix.

@param label-node   The label node.
@param prefix       The prefix for which to check in the label node.
|#
(def is-gensym-label
  (fn extern bool ((label-node (p DNode)) (prefix (p (const char))))
    (if (null (@:@ label-node token-str))
        (return false)
        0)
    (def match-str (var auto (array-of 150 char)))
    (sprintf match-str "_dale_internal_label_%s_" prefix)
    (if (!= 0 (strncmp (@:@ label-node token-str)
                       match-str
                       (strlen match-str)))
        (return false)
        0)
    (return true)))

#|
@fn std.macros.make-gensym-var-node

Generates a new variable name, constructs a token node to suit and
returns that node.

@param mc An MContext.
|#
(def make-gensym-var-node
  (fn extern (p DNode) ((mc (p MContext)))
    (def var-name
        (var auto \ (cast (pool-malloc mc (cast 30 size)) (p char))))
    (gensym-var var-name)
    (mnfv mc var-name)))

#|
@fn std.macros.walk-nodes

'Walks' through a node, recursively, calling the provided function
pointer on each node. The provided `data` argument is passed to the
function pointer on each call.

@param form     The node to walk.
@param mc An MContext.
@param data     Arbitrary data.
@param fn       The function pointer to call on each node.
|#
(def walk-nodes
  (fn extern bool ((form     (p DNode))
                   (mc (p MContext))
                   (data     (p void))
                   (fn       (p (fn int ((form     (p DNode))
                                         (mc (p MContext))
                                         (data     (p void)))))))
    (if (not (null (@:@ form list-node)))
        (walk-nodes (@:@ form list-node) mc data fn)
        true)
    (funcall fn form mc data)
    (if (not (null (@:@ form next-node)))
        (walk-nodes (@:@ form next-node) mc data fn)
        true)
    true))

#|
@fn std.macros.list-count

Takes a list node, and counts the number of nodes that are within that
list. This is not recursive: it just counts the top-level nodes from
the list.

@param form     A list node.
|#
(def list-count
  (fn extern int ((form (p DNode)))
    (def count     (var auto int 0))
    (def el-node (var auto (p DNode) (@ (:@ form list-node))))
    (label begin-loop)
      (if (null el-node)
          (goto end-loop)
          (do (setv count (+ count 1))
              (setv el-node (@ (:@ el-node next-node)))
              (goto begin-loop)))
    (label end-loop)
    (return count)))

#|
@fn std.macros.make-node-maker

Constructs a node that, when evaluated, constructs the provided node.
For example, if the node is a simple token, then the returned node
will be `(mnfv mc token-str)`, where `token-str` is the token
from the provided node.

@param mc       An MContext.
@param form     A node.
|#
(def make-node-maker
  (fn extern (p DNode) ((mc (p MContext)) (form (p DNode)))
    (def charbuf (var auto (array-of 256 char)))
    (def dquote (var auto char #\"))

    (def myres (var auto (p DNode)
    (if (= 0 (@:@ form is-list))
        (do
          (setf ($ charbuf 0) dquote)
          (strncpy ($ charbuf 1)
                   (@:@ form token-str)
                   (strlen (@:@ form token-str)))
          (setf ($ charbuf
                   (+ (cast 1 size) (strlen (@:@ form token-str))))
                dquote)
          (setf ($ charbuf
                   (+ (cast 2 size) (strlen (@:@ form token-str))))
                #\NULL)
          (link-nodes-list mc 3
                           (mnfv mc "std.macros.mnfv")
                           (mnfv mc "mc")
                           (mnfv mc charbuf)))
        (do
          (def holder
            (var auto (p DNode) (make-node mc)))
          (setf (:@ holder is-list) 1)
          (setf (:@ holder list-node) (nullptr DNode))
          (setf (:@ holder next-node) (nullptr DNode))
          (def topnode
            (var auto (p DNode) (mnfv mc "std.macros.link-nodes-list")))
          (setf (:@ holder list-node) topnode)
          (def poolnode
            (var auto (p DNode) (mnfv mc "mc")))
          (setf (:@ topnode next-node) poolnode)

          (def cnode
            (var auto \ (@:@ form list-node)))
          (def count (var auto \ 1))
          (label begin)
            (if (null (@:@ cnode next-node))
                (goto end)
                (do (setv count (+ count 1))
                    (setv cnode (@:@ cnode next-node))
                    (goto begin)))
          (label end)

          (def countnode
            (var auto (p DNode) (mnfv mc count)))
          (setf (:@ poolnode next-node) countnode)

          (def elnode (var auto (p DNode) countnode))
          (def nextelnode (var auto (p DNode)))

          (setv cnode (@:@ form list-node))

          (label begin2)
            (do (setv nextelnode (make-node-maker mc cnode))
                (setf (:@ elnode next-node) nextelnode)
                (setv elnode nextelnode)
                (if (null (@:@ cnode next-node))
                    (goto end2)
                    (do (setv cnode (@:@ cnode next-node))
                        (goto begin2))))
          (label end2)
            holder))))

    (return myres)))

(def itoa-str (var intern (array-of 50 char)))
(def itoa
  (fn extern (p char) ((n int))
    (sprintf itoa-str "%d" n)
    (return itoa-str)))

#|
@fn std.macros.bqq-helper

A helper function for `bqq` (bootstrap-qq).

@param frm          A node.
@param mc           An MContext.
@param arg-count    The number of elements in the node.
|#
(def bqq-helper
  (fn intern (p DNode) ((frm (p DNode))
                        (mc  (p MContext))
                        (arg-count int))
    (def nullp (var auto (p DNode) (cast 0 (p DNode))))

    (def holder (var auto (p DNode) (make-node mc)))
    (setf (:@ holder is-list)   1)
    (setf (:@ holder list-node) nullp)
    (setf (:@ holder next-node) nullp)

    (def ln-node (var auto (p DNode)
                    (mnfv mc "std.macros.link-nodes-list-wp")))
    (setf (:@ holder list-node) ln-node)

    (def pool-node (var auto (p DNode) (mnfv mc "mc")))
    (setf (:@ ln-node next-node) pool-node)

    (def count-node (var auto (p DNode) (mnfv mc (itoa arg-count))))
    (setf (:@ pool-node next-node) count-node)

    (def begin-line-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) begin-line)))))
    (setf (:@ count-node next-node) begin-line-node)

    (def begin-column-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) begin-column)))))
    (setf (:@ begin-line-node next-node) begin-column-node)

    (def end-line-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) end-line)))))
    (setf (:@ begin-column-node next-node) end-line-node)

    (def end-column-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) end-column)))))
    (setf (:@ end-line-node next-node) end-column-node)

    (def macro-begin-line-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) macro-begin-line)))))
    (setf (:@ end-column-node next-node) macro-begin-line-node)

    (def macro-begin-column-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) macro-begin-column)))))
    (setf (:@ macro-begin-line-node next-node) macro-begin-column-node)

    (def macro-end-line-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) macro-end-line)))))
    (setf (:@ macro-begin-column-node next-node) macro-end-line-node)

    (def macro-end-column-node (var auto (p DNode)
        (mnfv mc (itoa (@:@ (@:@ frm list-node) macro-end-column)))))
    (setf (:@ macro-end-line-node next-node) macro-end-column-node)

    (def anchor-node (var auto (p DNode) macro-end-column-node))

    (def va-dnode (var auto (p DNode)))
    (def temp-node (var auto (p DNode)))

    (def charbuf (var auto (array-of 256 char)))
    (def dquote (var auto char #\"))
    (def token-str (var auto (p char)))
    (def qq-node (var auto (p DNode)))

    (def begin (var auto int 1))

    (label begin-loop)
      (if (= arg-count 0)
          (goto end-loop)
          (do
            (setv va-dnode
                (if (= begin 1)
                    (@:@ frm list-node)
                    (@:@ va-dnode next-node)))

            (setv begin 0)
            (setv arg-count (- arg-count 1))

            (if (= 0 (@ (:@ va-dnode is-list)))
                (do
                    (setf ($ charbuf 0) dquote)
                    (setv token-str (@ (:@ va-dnode token-str)))
                    (strncpy ($ charbuf 1) token-str (strlen token-str))
                    (setf ($ charbuf (+ (cast 1 size) (strlen token-str))) dquote)
                    (setf ($ charbuf (+ (cast 2 size) (strlen token-str))) #\NULL)

                    (setv temp-node (link-nodes-list mc 11
                        (mnfv mc "std.macros.mnfv-wp")
                        (mnfv mc "mc")
                        (mnfv mc charbuf)
                        (mnfv mc (itoa (@:@ va-dnode begin-line)))
                        (mnfv mc (itoa (@:@ va-dnode begin-column)))
                        (mnfv mc (itoa (@:@ va-dnode end-line)))
                        (mnfv mc (itoa (@:@ va-dnode end-column)))
                        (mnfv mc (itoa (@:@ va-dnode macro-begin-line)))
                        (mnfv mc (itoa (@:@ va-dnode macro-begin-column)))
                        (mnfv mc (itoa (@:@ va-dnode macro-end-line)))
                        (mnfv mc (itoa (@:@ va-dnode macro-end-column)))))
                    (setf (:@ anchor-node next-node) temp-node)
                    (setv anchor-node temp-node)
                    0)
            (do
                (if (if (not (null (@:@ va-dnode list-node)))
                        (if (= 0 (@:@ (@:@ va-dnode list-node) is-list))
                            true
                            false)
                        false)
                    (if (if (= 0 (strcmp (@:@ (@:@ va-dnode list-node) token-str) "uq"))
                            (if (not (null (@:@ (@:@ va-dnode list-node) next-node)))
                                true
                                false)
                            false)
                        (do
                            (setv temp-node
                                (if (not (null (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str)))
                                    (link-nodes-list mc 4 (mnfv mc "std.macros.copy") (mnfv mc "mc") (mnfv mc "false") (mnfv mc (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str)))
                                    (link-nodes-list mc 4 (mnfv mc "std.macros.copy") (mnfv mc "mc") (mnfv mc "false") (make-node-maker mc (@:@ (@:@ va-dnode list-node) next-node)))))
                            (setf (:@ anchor-node next-node) temp-node)
                            (setv anchor-node temp-node) 0)
                    (if (if (= 0 (strcmp (@:@ (@:@ va-dnode list-node) token-str) "uql"))
                            (if (not (null (@:@ (@:@ va-dnode list-node) next-node)))
                                true
                                false)
                            false)
                        (do
                            (setv temp-node
                                (if (not (null (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str)))
                                    (link-nodes-list mc 4 (mnfv mc "std.macros.copy") (mnfv mc "mc") (mnfv mc "true") (mnfv mc (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str)))
                                    (link-nodes-list mc 4 (mnfv mc "std.macros.copy") (mnfv mc "mc") (mnfv mc "true") (make-node-maker mc (@:@ (@:@ va-dnode list-node) next-node)))))
                            (setf (:@ anchor-node next-node) temp-node)
                            (setv anchor-node (get-last-node temp-node)
                            ) 0)
                    (if (if (= 0 (strcmp (@:@ (@:@ va-dnode list-node) token-str) "uq-nc"))
                            (if (not (null (@:@ (@:@ va-dnode list-node) next-node)))
                                true
                                false)
                            false)
                        (do
                            (setv temp-node
                                (if (not (null (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str)))
                                    (mnfv mc (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str))
                                    (make-node-maker mc (@:@ (@:@ va-dnode list-node) next-node))))
                            (setf (:@ anchor-node next-node) temp-node)
                            (setv anchor-node temp-node)
                            0)
                    (if (if (= 0 (strcmp (@:@ (@:@ va-dnode list-node) token-str) "uql-nc"))
                            (if (not (null (@:@ (@:@ va-dnode list-node) next-node)))
                                true
                                false)
                            false)
                        (do
                            (setv temp-node
                                (if (not (null (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str)))
                                    (mnfv mc (@:@ (@:@ (@:@ va-dnode list-node) next-node) token-str))
                                    (make-node-maker mc (@:@ (@:@ va-dnode list-node) next-node))))
                            (setf (:@ anchor-node next-node) temp-node)
                            (setv anchor-node (get-last-node temp-node))
                            0)
                    (do
                        (setv temp-node
                            (bqq-helper va-dnode
                                    mc
                                    (list-count va-dnode)))
                        (setf (:@ anchor-node next-node)
                            temp-node)
                        (setv anchor-node (get-last-node temp-node)) 0)))))
                (do
                    (setv temp-node
                          (if (null (@:@ va-dnode list-node))
                              (make-empty-list-node mc)
                              (bqq-helper va-dnode
                                          mc
                                          (list-count va-dnode))))
                    (setf (:@ anchor-node next-node)
                        temp-node)
                    (setv anchor-node (get-last-node temp-node))
                    0))))
            (goto begin-loop)))

    (label end-loop)
      (return holder)))

#|
@macro std.macros.bqq

The bootstrap quasiquotation macro. The general-use quasiquotation
macro, `qq`, is in the `macros` module. The forms handled specially
are `uq` (unquote), `uq-nc` (unquote-no-copy), `uql` (unquote-list)
and `uql-nc` (unquote-list-no-copy). The no-copy versions of these
forms should only be used when the nodes being unquoted will not be
used again.

@param frm      A node.
|#
(def bqq (macro intern (frm rest)
    (def arg-count (var auto \ (arg-count mc)))

    (setv arg-count (- arg-count 1))
    (def myargcount (var auto int arg-count))

    (def nullp (var auto (p DNode) (nullptr DNode)))
    (def holder (var auto (p DNode) (make-node mc)))

    (def va-dnode (var auto (p DNode)))
    (def temp-node (var auto (p DNode)))

    (def begin (var auto int 0))

    (setf (:@ holder is-list)   1)
    (setf (:@ holder list-node) frm)
    (setf (:@ holder next-node) nullp)
    (setv temp-node frm)

    (label begin-loop)
        (if (= arg-count 0) (goto end-loop) 0)

        (setv va-dnode (@$ rest begin))
        (setv begin (+ begin 1))
        (setf (:@ temp-node next-node) va-dnode)
        (setv temp-node va-dnode)
        (setv arg-count (- arg-count 1))
        (goto begin-loop)

    (label end-loop)
        (def x (var auto \ (bqq-helper holder mc (+ myargcount 1))))
        (return x)))

#|
@macro @:'

Takes a struct pointer and one or more struct member names as its
arguments. Expands to repeated calls to `@:@` over the struct and the
member names. For example, if two members are provided, the expansion
is `(@:@ (@:@ structp member1) member2)`.

@param structp      The struct pointer argument.
@param member       The first member's name.
|#
(def @:'
  (macro extern (structp member rest)
    (def arg-count (var auto \ (arg-count mc)))
    (setv arg-count (- arg-count 2))
    (def myargcount (var auto int arg-count))

    (def frm (var auto (p DNode) (std.macros.bqq @:@ (uq-nc structp) (uq-nc member))))
    (def va-dnode (var auto (p DNode)))

    (def begin (var auto int 0))

    (label begin-loop)
        (if (= arg-count 0) (goto end-loop) 0)

        (setv va-dnode (@$ rest begin))
        (setv begin (+ begin 1))
        (setv frm (std.macros.bqq @:@ (uq-nc frm) (uq-nc va-dnode)))
        (setv arg-count (- arg-count 1))
        (goto begin-loop)

    (label end-loop)
        (return frm)))

(def is-unquote-node (fn extern bool ((frm (p DNode)))
  (def ts (var auto \ (@:@ frm token-str)))
  (if (null ts)
      (do (return false) true)
      true)
  (if (= 0 (strcmp ts "uq"))
      (do (return true) true)
      true)
  (if (= 0 (strcmp ts "uql"))
      (do (return true) true)
      true)
  (if (= 0 (strcmp ts "uq-nc"))
      (do (return true) true)
      true)
  (if (= 0 (strcmp ts "uql-nc"))
      (do (return true) true)
      true)
  (return false)))

(def is-unquote-form (fn extern bool ((frm (p DNode)))
  (def list-node (var auto \ (@:@ frm list-node)))
  (if (null list-node)
      (do (return false) true)
      true)
  (def next-node (var auto \ (@:@ list-node next-node)))
  (if (null next-node)
      (do (return false) true)
      true)
  (return (is-unquote-node list-node))))

(def ct-node-checks (fn extern bool ((mc (p MContext)) (frm (p DNode)))
  (if (is-unquote-form frm)
      (do (return true) true)
      true)
  (def frm-type (var auto \ (type-of mc frm true)))
  (if (null frm-type)
      (do (return false))
      true)
  (if (not (types-equal mc frm-type (q (p DNode))))
      (do (report-error mc frm "only DNodes may be unquoted")
          (return false))
      true)
  true))

(def excise-empty-nodes (fn extern bool ((mc (p MContext)) (frm (p DNode)))
  (if (null frm)
      (return false)
      true)
  (if (not (null (@:@ frm list-node)))
      (do (if (is-empty-node (@:@ frm list-node))
              (do (setf (:@ frm list-node)
                        (@:' frm list-node next-node))
                  (excise-empty-nodes mc frm)
                  true)
              true)
          (do (excise-empty-nodes mc (@:@ frm list-node))
              true))
      true)
  (if (not (null (@:@ frm next-node)))
      (do (if (is-empty-node (@:@ frm next-node))
              (do (setf (:@ frm next-node)
                        (@:' frm next-node next-node))
                  (excise-empty-nodes mc frm)
                  true)
              true)
          (do (excise-empty-nodes mc (@:@ frm next-node))
              true))
      true)
  true))

#|
@macro qq

The 'general-use' quasiquotation macro. The forms handled specially
are:

  * `uq` (unquote): expands to the argument node, excluding any
    following nodes (i.e. excluding `next-node`);
  * `uql` (unquote-list): expands to the argument node, including all
    following nodes (i.e. including `next-node` and any subsequent
    `next-node`s of that node);
  * `uq-nc` (unquote no-copy): as per `uq`, except that the argument
    node is not copied on substitution; and
  * `uql-nc` (unquote-list no-copy): as per `uql`, except that the nodes
    are not copied on substitution.

Quasiquotation forms may be nested: each specially-handled form in a
nested `qq` must be wrapped with an additional `uq` for each level of
nesting.

The `-nc` versions should only be used when the argument node will not
be used again.

Previously, argument nodes for the various special forms had to be
DNode pointer variable names.  Arbitrary forms as argument nodes are
now supported.  For example, `(qq identity (uq (mnfv mc 1)))`
previously expanded to `(identity (mnfv mc 1))`, and now expands to
`(identity 1)`.

@linkage extern
|#
(def qq (macro extern (frm rest)
    (def arg-count (var auto \ (arg-count mc)))
    (setv arg-count (- arg-count 1))
    (def myargcount (var auto int arg-count))

    (def nullp (var auto (p DNode) (nullptr DNode)))
    (def holder (var auto (p DNode) (make-node mc)))
    (copy-to holder frm)
    (setf (:@ holder token-str) (nullptr char))
    (setf (:@ holder list-node) (nullptr DNode))

    (def va-dnode (var auto (p DNode)))
    (def temp-node (var auto (p DNode)))

    (def begin (var auto int 0))

    (setf (:@ holder is-list) 1)
    (setf (:@ holder list-node) frm)
    (setf (:@ holder next-node) nullp)
    (setv temp-node frm)
    (label begin-loop)
        (if (= arg-count 0) (goto end-loop) 0)

        (setv va-dnode (@$ rest begin))
        (setv begin (+ begin 1))
        (setf (:@ temp-node next-node) va-dnode)
        (setv temp-node va-dnode)
        (setv arg-count (- arg-count 1))
        (goto begin-loop)

    (label end-loop)

    (def vn (var auto \ (make-gensym-var-node mc)))

    (def current-firstnode (var auto (p DNode) (bqq std.macros.@:' (uq vn) list-node)))
    (def current-lastnode  (var auto (p DNode)
        (@:' current-firstnode list-node next-node next-node)))

    (def blocks (var auto (array-of 255 (p DNode))))
    (def block-count (var auto \ 0))

    (def cn (var auto (p DNode) (@:' holder list-node)))
    (def upvs (var auto (array-of 256 (p DNode))))
    (def upvs-count (var auto int 0))
    (def lastnodes (var auto (array-of 256 (p DNode))))

    (def tempform (var auto (p DNode)))

    (def repl-next (var auto int 0))
    (def processed-list (var auto int 0))
    (def no-down (var auto int 0))

    ;(printf "qq flag 3\n")

    (label begin-loop2)

        (do (if (is-non-empty-list cn)
                (do ;(printf "CN is list\n")
                (if (not (is-non-empty-list (@:' cn list-node)))
                    (do ;(printf "CN is list with first token: %s\n"
                                ;(@:' cn list-node token-str))
                    (if (if (= 0 (strcmp (@:' cn list-node token-str) "uq"))
                            (if (not (null (@:' cn list-node next-node)))
                                true
                                false)
                            false)
                        (do ;(printf "CN is uq!\n")
                            (setv processed-list 1)
                        (do (def checkform (var auto \ (@:' cn list-node next-node)))
                            (setv tempform
                                (if (not (null (@:' checkform list-node)))
                                    (if (is-unquote-node (@:' checkform list-node))
                                        (do (setv no-down 1)
                                            (make-node-maker mc
                                                             (@:' cn
                                                                  list-node
                                                                  next-node)))
                                        checkform)
                                    checkform))
                            (if (not (ct-node-checks mc checkform))
                                (return (nullptr DNode))
                                true)
                            (def vn (var auto \ (make-gensym-var-node
                                                 mc)))
                            (setf ($ blocks block-count) (bqq do
                                (setv firstnode (uq current-firstnode))
                                (def (uq vn) (var auto \ (uq tempform)))
                                (if (null (uq vn))
                                    (do (report-error mc firstnode "unquoting null node")
                                        false)
                                    (do (setv newnode
                                        (std.macros.copy mc false (uq vn)))
                                        (std.macros.copy-to firstnode newnode)
                                        true))))
                            (setv block-count (+ block-count 1))
                            ;(getchar)
                            0))
                    (if (if (= 0 (strcmp (@:' cn list-node token-str) "uql"))
                            (if (not (null (@:' cn list-node next-node)))
                                true
                                false)
                            false)
                        (do ;(printf "CN is uq!\n")
                            (setv processed-list 1)
                        (do (def checkform (var auto \ (@:' cn list-node next-node)))
                            (setv tempform
                                (if (not (null (@:' checkform list-node)))
                                    (if (is-unquote-node (@:' checkform list-node))
                                        (do (setv no-down 1)
                                            (make-node-maker mc
                                                             (@:' cn
                                                                  list-node
                                                                  next-node)))
                                        checkform)
                                    checkform))
                            (if (not (ct-node-checks mc tempform))
                                (return (nullptr DNode))
                                true)
                            (setv no-down 1)
                            (def vn (var auto \ (make-gensym-var-node
                                                 mc)))
                            (def vn2  (var auto \ (make-gensym-var-node
                                                   mc)))
                            (setf ($ blocks block-count) (bqq do
                                (def (uq vn2) (var auto \ (uq tempform)))
                                (setv firstnode (uq current-firstnode))
                                (if (null (uq vn2))
                                    (do (report-error mc firstnode "unquoting null node")
                                        false)
                                    (do (setv newnode (std.macros.copy mc
                                                        true (uq vn2)))
                                        (std.macros.copy-to firstnode newnode)
                                        (if (not (null (@:@ newnode next-node)))
                                            (do (def (uq vn)
                                                  (var auto \ (@:@ firstnode next-node)))

                                                (setf (:@ firstnode next-node)
                                                      (@:@ newnode next-node))
                                                (setf (:@ (std.macros.get-last-node newnode) next-node)
                                                      (uq vn)))
                                            0)))))
                            (setv block-count (+ block-count 1))
                            ;(getchar)
                            0))
                    (if (if (= 0 (strcmp (@:' cn list-node token-str) "uq-nc"))
                            (if (not (null (@:' cn list-node next-node)))
                                true
                                false)
                            false)
                        (do ;(printf "CN is uq!\n")
                            (setv processed-list 1)
                        (do (def checkform (var auto \ (@:' cn list-node next-node)))
                            (setv tempform
                                (if (not (null (@:' checkform list-node)))
                                    (if (is-unquote-node (@:' checkform list-node))
                                        (do (setv no-down 1)
                                            (make-node-maker mc
                                                             (@:' cn
                                                                  list-node
                                                                  next-node)))
                                        checkform)
                                    checkform))
                            (if (not (ct-node-checks mc tempform))
                                (return (nullptr DNode))
                                true)
                            (def vn (var auto \ (make-gensym-var-node
                                                 mc)))
                            (setv no-down 1)
                            (setf ($ blocks block-count) (bqq do
                                (setv firstnode (uq current-firstnode))
                                (def (uq vn) (var auto \ (uq tempform)))
                                (if (null (uq vn))
                                    (do (report-error mc firstnode "unquoting null node")
                                        false)
                                    (do (setv newnode (uq vn))
                                        (std.macros.copy-to firstnode newnode)
                                        true))))
                            (setv block-count (+ block-count 1))
                            ;(getchar)
                            0))
                    (if (if (= 0 (strcmp (@:' cn list-node token-str) "uql-nc"))
                            (if (not (null (@:' cn list-node next-node)))
                                true
                                false)
                            false)
                        (do ;(printf "CN is uq!\n")
                            (setv processed-list 1)
                        (do (def checkform (var auto \ (@:' cn list-node next-node)))
                            (setv tempform
                                (if (not (null (@:' checkform list-node)))
                                    (if (is-unquote-node (@:' checkform list-node))
                                        (do (setv no-down 1)
                                            (make-node-maker mc
                                                             (@:' cn
                                                                  list-node
                                                                  next-node)))
                                        checkform)
                                    checkform))
                            (if (not (ct-node-checks mc tempform))
                                (return (nullptr DNode))
                                true)
                            (def vn (var auto \ (make-gensym-var-node
                                                 mc)))
                            (setv no-down 1)
                            (setf ($ blocks block-count) (bqq do
                                (setv firstnode (uq current-firstnode))
                                (def (uq vn) (var auto \ (uq tempform)))
                                (if (null (uq vn))
                                    (do (report-error mc firstnode "unquoting null node")
                                        false)
                                    (do (setv newnode (uq vn))
                                        (std.macros.copy-to firstnode newnode)
                                        (if (not (null (@:@ newnode next-node)))
                                            (do (def tv222
                                                  (var auto \ (@:@ firstnode next-node)))
                                                (setf (:@ firstnode next-node)
                                                      (@:@ newnode next-node))
                                                (setf (:@ (std.macros.get-last-node newnode) next-node)
                                                      tv222))
                                            0)))))
                            (setv block-count (+ block-count 1))
                            ;(getchar)
                            0))
                        0)))))
                    0))
                0)

            (if (if (= 0 no-down)
                    (if (not (null (@:@ cn list-node)))
                        true
                        false)
                    false)
                (do ;(printf "Moving down into this list: ") (DNode-print cn) (printf "\n")

                    (setf ($ upvs upvs-count) cn)
                    (setf ($ lastnodes upvs-count) current-lastnode)
                    (setv upvs-count (+ upvs-count 1))

                    (setf (:@ current-lastnode next-node)
                          (mnfv mc "list-node"))
                    (setv current-lastnode
                          (@:@ current-lastnode next-node))
                    (setv cn (@:@ cn list-node))
                    (goto begin-loop2))

            (if (not (null (@:@ cn next-node)))
                (do ;(printf "Moving to next node in this list: ") (DNode-print cn) (printf "\n")
                    (setv no-down 0)
                    (setf (:@ current-lastnode next-node)
                          (mnfv mc "next-node"))
                    (setv current-lastnode
                          (@:@ current-lastnode next-node))
                    (setv cn (@:@ cn next-node))
                    (goto begin-loop2))

            (if (> upvs-count 0)
                (do ;(printf "Moving upwards: ") (DNode-print cn) (printf "\n")
                    (setv no-down 0)
                    (label while-begin)
                    (if (> upvs-count 0)
                        (do (setv upvs-count (- upvs-count 1))
                            (setv cn (@ ($ upvs upvs-count)))
                            (setv current-lastnode (@ ($ lastnodes upvs-count)))
                            (if (not (null (@:@ cn next-node)))
                                (do
                                    (setf (:@ current-lastnode next-node)
                                        (mnfv mc "next-node"))
                                    (setv current-lastnode
                                        (@:@ current-lastnode next-node))
                                    (setv cn (@:@ cn next-node))
                                    (goto begin-loop2))
                                0)
                            (goto while-begin))
                        (goto end-loop2))
                    (goto end-loop2))


                (goto end-loop2)))))

    (label end-loop2)
        (def block-start (var auto (p DNode) (nullptr DNode)))
        (def block-last (var auto (p DNode) (nullptr DNode)))
        (label block-loop)
        (if (= 0 block-count)
            (goto block-loop-end)
            (do (setv block-count (- block-count 1))
                (if (null block-start)
                    (do (setv block-start (@$ blocks block-count))
                        (setv block-last block-start))
                    (do (setf (:@ block-last next-node) (@$ blocks block-count))
                        (setv block-last (@:@ block-last next-node))))
                (goto block-loop)))
        (label block-loop-end)
        (if (null block-start)
            (setv block-start (mnfv mc "0"))
            0)

        (def res (var auto \ (bqq do (new-scope
            (def (uq vn) (var auto (p DNode) (std.macros.copy mc true
            (q (uq-nc holder)))))
            (def firstnode (var auto (p DNode)))
            (def trailing  (var auto (p DNode)))
            (def newnode   (var auto (p DNode)))
            (uql-nc block-start)
            (def node-holder (var auto \ (std.macros.make-node mc)))
            (setf (:@ node-holder list-node) (uq vn))
            (setf (:@ node-holder is-list) 1)
            (std.macros.excise-empty-nodes mc node-holder)
            (setv (uq vn) (@:@ node-holder list-node))
            (uq vn)))))
          ;(DNode-print res)
          ;(printf "\n")
          res))

#|
@macro std.macros.get-varargs-list

Takes a macro context, an argument count, and a pointer to a DNode
pointer as its arguments.  Returns the first node of a linked node
list containing each of the nodes from the DNode pointer list,
suitable for using as the argument to the `uql` and `uql-nc` forms.
(The third argument here is typically the macro's 'rest' argument.
The difference between 'rest' and the return value of this function is
that the nodes here will be linked together.)

@linkage extern
|#
(def get-varargs-list
  (fn extern (p DNode) ((mc (p MContext)) (arg-count int) (arglist (p (p DNode))))
    (if (= arg-count 0)
        (return (make-node mc))
        true)
    (def arg-count-original (var auto int arg-count))
    (def arg-array-original
        (var auto (p (p DNode))
                (cast (pool-malloc mc
                                   (* (sizeof (p DNode))
                                      (cast arg-count size)))
                      (p (p DNode)))))
    (def arg-array (var auto (p (p DNode)) arg-array-original))
    (def index (var auto int 0))

    (label begin)
      (if (= arg-count 0)
        (goto end)
        (do
            (setf arg-array (@$ arglist index))
            (setv index (+ index 1))
            (setv arg-array (p+ arg-array 1))
            (setv arg-count (- arg-count 1))
            (goto begin)))

    (label end)
      (return (link-nodes-array arg-count-original
                                arg-array-original))))


; Helper function only, use the simple version instead.
(def get-varargs-list (macro extern (name (count int))
  (qq do
    (def (uq name) (var auto (p DNode)))
    (new-scope
      (setv (uq name) (std.macros.get-varargs-list mc (uq count) rest))))))

#|
@macro std.macros.get-varargs-list

Simple version of `get-varargs-list`, only takes the count as parameter.

@linkage extern
|#
(def get-varargs-list (macro extern ((count int))
  (def name (var auto \ (make-gensym-var-node mc)))
  (qq do
    (std.macros.get-varargs-list (uq name) (uq count))
    (move (uq name)))))

(def pool-malloc' (macro extern (n T)
  (qq cast (pool-malloc mc (* (cast (uq n) size) (sizeof (uq T))))
            (p (uq T)))))

#|
@fn std.macros.map-nodes

Similar to `walk-nodes`, except that it does not descend into list
nodes, and the provided function returns a node (possibly different
from the argument node), rather than mutating the argument node in
place.

@param mc       An MContext.
@param form     The node to map.
@param data     Arbitrary data.
@param fn       The function pointer to call for each node.
|#
(def map-nodes
  (fn (attr cto) extern (p DNode) ((mc   (p MContext))
                                   (list (p DNode))
                                   (data (p void))
                                   (fn   (p (fn (p DNode) ((mc   (p MContext))
                                                           (node (p DNode))
                                                           (data (p void)))))))
    (def elt (var auto \ (funcall fn mc list data)))
    (if (not (null (@:@ list next-node)))
        (new-scope
          (def remaining
            (var auto \ (@:@ (map-nodes mc (@:@ list next-node) data fn)
                             list-node)))
          (qq (uq elt) (uql remaining)))
        (qq (uq elt)))))
))
